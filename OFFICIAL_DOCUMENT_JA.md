https://code.claude.com/docs/en/agent-teams

*****
Claude Codeで構築する
Claude Codeセッションのチームをオーケストレーションする

共有タスク、エージェント間メッセージング、集中管理により、チームとして連携する複数のClaude Codeインスタンスを調整します。

エージェントチームは実験的な機能であり、デフォルトで無効になっています。settings.jsonまたは環境変数にCLAUDE_CODE_EXPERIMENTAL_AGENT_TEAMSを追加して有効にします。エージェントチームには、セッション再開、タスク調整、シャットダウン動作に関する既知の制限があります。
エージェントチームを使用すると、複数のClaude Codeインスタンスの連携を調整できます。1つのセッションがチームリーダーとして機能し、作業の調整、タスクの割り当て、結果の統合を行います。チームメイトはそれぞれ独自のコンテキストウィンドウで独立して作業し、互いに直接通信します。
サブエージェントは単一セッション内で実行され、メインエージェントにしか報告できませんが、エージェントチームではリーダーを介さずに個々のチームメイトと直接対話することもできます。
このページでは以下を説明します：
- エージェントチームを使用するタイミング（ベストプラクティスとサブエージェントとの比較を含む）
- チームの開始方法
- チームメイトの制御方法（表示モード、タスク割り当て、委任を含む）
- 並列作業のベストプラクティス

エージェントチームを使用するタイミング
エージェントチームは、並列探索が実際の価値を生むタスクで最も効果的を発揮します。完全なシナリオについてはユースケースの例を参照してください。最も強力なユースケースは以下の通りです：
- リサーチとレビュー：複数のチームメイトが問題の異なる側面を同時に調査し、発見を共有し、互いの発見を検証できます
- 新しいモジュールや機能：チームメイトがそれぞれ別の部分を所有し、互いに干渉せずに作業できます
- 競合する仮説でのデバッグ：チームメイトが異なる理論を並列でテストし、より迅速に結論に到達します
- クロスレイヤーの調整：フロントエンド、バックエンド、テストにまたがる変更をそれぞれ別のチームメイトが所有します
エージェントチームには調整のオーバーヘッドが追加され、単一セッションよりもはるかに多くのトークンを消費します。チームメイトが独立して操作できる場合に最適に機能します。順次タスク、同一ファイルの編集、多くの依存関係を持つ作業の場合、単一セッションまたはサブエージェントの方が効果的です。

サブエージェントとの比較
エージェントチームとサブエージェントの両方は作業を並列化できますが、動作は異なります。ワーカーが互いに通信する必要があるかに基づいて選択してください：

| 項目 | サブエージェント | エージェントチーム |
|------|-----------------|-------------------|
| コンテキスト | 独自のコンテキストウィンドウ；結果は呼び出し元に返される | 独自のコンテキストウィンドウ；完全に独立 |
| 通信 | 結果をメインエージェントにのみ報告 | チームメイトが互いに直接メッセージを送信 |
| 調整 | メインエージェントがすべての作業を管理 | 共有タスクリストと自己調整 |
| 最適な用途 | 結果のみが重要な集中タスク | 議論とコラボレーションを必要とする複雑な作業 |
| トークンコスト | 低い：結果はメインコンテキストに要約されて返される | 高い：各チームメイトは別のClaudeインスタンス |

結果を報告する迅速な集中ワーカーが必要な場合はサブエージェントを使用してください。チームメイトが発見を共有し、互いに検証し、独自に調整する必要がある場合はエージェントチームを使用してください。

エージェントチームを有効にする
エージェントチームはデフォルトで無効になっています。シェル環境またはsettings.jsonを通じてCLAUDE_CODE_EXPERIMENTAL_AGENT_TEAMS環境変数を1に設定して有効にします：

settings.json
{
  "env": {
    "CLAUDE_CODE_EXPERIMENTAL_AGENT_TEAMS": "1"
  }
}

最初のエージェントチームを開始する
エージェントチームを有効にした後、Claudeにエージェントチームを作成するよう指示し、自然言語でタスクとチーム構造を説明します。Claudeはチームを作成し、チームメイトを生成し、プロンプトに基づいて作業を調整します。
この例は3つの役割が独立しており、互いを待つことなく問題を探索できるため、うまく機能します：
```
開発者がコードベース全体のTODOコメントを追跡するのを助けるCLIツールを設計しています。
エージェントチームを作成して、さまざまな角度からこれを探索してください：UX担当1名、
技術アーキテクチャ担当1名、悪魔の代言人（devil's advocate）1名。
```
そこから、Claudeは共有タスクリストでチームを作成し、各視点のチームメイトを生成し、問題を探索させ、発見を統合し、完了したときにチームをクリーンアップしようとします。
リーダーのターミナルにはすべてのチームメイトとその作業内容が表示されます。Shift+Up/Downを使用してチームメイトを選択し、直接メッセージを送信できます。
各チームメイトを独自の分割ペインに配置する場合は、「表示モードを選択する」を参照してください。

エージェントチームを制御する
自然言語でリーダーに望むことを伝えてください。指示に基づいてチーム調整、タスク割り当て、委任を処理します。

表示モードを選択する
エージェントチームは2つの表示モードをサポートしています：
- インプロセス：すべてのチームメイトがメインターミナル内で実行されます。Shift+Up/Downを使用してチームメイトを選択し、入力して直接メッセージを送信します。任意のターミナルで動作し、追加のセットアップは不要です。
- 分割ペイン：各チームメイトが独自のペインを取得します。すべての出力を一度に確認でき、ペインをクリックして直接対話できます。tmuxまたはiTerm2が必要です。
tmuxは特定のオペレーティングシステムでは既知の制限があり、従来macOSで最適に機能します。iTerm2でtmux -CCを使用することが、tmuxへの推奨されるエントリーポイントです。
デフォルトは「auto」で、すでにtmuxセッション内で実行している場合は分割ペインを使用し、それ以外の場合はインプロセスを使用します。「tmux」設定は分割ペインモードを有効にし、ターミナルに基づいてtmuxまたはiTerm2の使用を自動検出します。上書きするには、settings.jsonでteammateModeを設定します：
```
{
  "teammateMode": "in-process"
}
```
単一セッションでインプロセスモードを強制するには、フラグとして渡します：
```
claude --teammate-mode in-process
```
分割ペインモードにはtmuxまたはiTerm2とit2 CLIが必要です。手動でインストールするには：
- tmux：システムのパッケージマネージャーからインストールします。プラットフォーム固有の手順についてはtmux wikiを参照してください。
- iTerm2：it2 CLIをインストールし、iTerm2 → 設定 → 一般 → マジック → Python APIを有効にするでPython APIを有効にします。

チームメイトとモデルを指定する
Claudeはタスクに基づいて生成するチームメイトの数を決定しますが、希望を明確に指定することもできます：
```
これらのモジュールを並列でリファクタリングするために4人のチームメイトでチームを作成してください。
各チームメイトにSonnetを使用してください。
```

チームメイトに計画承認を要求する
複雑またはリスクの高いタスクの場合、チームメイトに実装前に計画を要求できます。チームメイトはリーダーがアプローチを承認するまで、読み取り専用の計画モードで作業します：
```
認証モジュールをリファクタリングするためにアーキテクトチームメイトを生成してください。
変更を加える前に計画承認を要求してください。
```
チームメイトが計画を完了すると、計画承認リクエストをリーダーに送信します。リーダーは計画をレビューし、承認するかフィードバック付きで拒否します。拒否された場合、チームメイトは計画モードのままとなり、フィードバックに基づいて修正し、再提出します。承認されると、チームメイトは計画モードを終了し、実装を開始します。
リーダーは承認の決定を自律的に行います。リーダーの判断に影響を与えるには、プロンプトに基準を含めます。「テストカバレッジを含む計画のみを承認する」や「データベーススキーマを変更する計画を拒否する」などです。

委任モードを使用する
委任モードなしでは、リーダーはチームメイトを待つ代わりにタスクの実装を開始することがあります。委任モードは、リーダーを調整のみのツール（生成、メッセージング、チームメイトのシャットダウン、タスク管理）に制限することでこれを防ぎます。
これは、コードを直接操作することなく、作業の分解、タスクの割り当て、結果の統合など、リーダー完全にオーケストレーションに集中させたい場合に便利です。
有効にするには、まずチームを開始し、Shift+Tabを押して委任モードに切り替えます。

チームメイトと直接話す
各チームメイトは完全な独立したClaude Codeセッションです。追加の指示、フォローアップの質問、アプローチの変更を直接伝えるために、任意のチームメイトにメッセージを送信できます。
- インプロセスモード：Shift+Up/Downを使用してチームメイトを選択し、入力してメッセージを送信します。Enterを押してチームメイトのセッションを表示し、Escapeを押して現在のターンを中断します。Ctrl+Tを押してタスクリストを切り替えます。
- 分割ペインモード：チームメイトのペインをクリックしてセッションと直接対話します。各チームメイトは独自のターミナルの完全なビューを持ちます。

タスクを割り当てて要求する
共有タスクリストはチーム全体の作業を調整します。リーダーがタスクを作成し、チームメイトがそれらを処理します。タスクには3つの状態があります：保留中、進行中、完了。タスクは他のタスクに依存することもできます。解決されていない依存関係を持つ保留中のタスクは、それらの依存関係が完了するまで要求できません。
リーダーはタスクを明示的に割り当てることができますが、チームメイトが自己要求することもできます：
- リーダー割り当て：リーダーにどのタスクをどのチームメイトに与えるか伝えます
- 自己要求：タスクを完了した後、チームメイトは独自に次の未割り当てで未ブロックのタスクを取得します
タスク要求はファイルロックを使用して、複数のチームメイトが同時に同じタスクを要求する際の競合状態を防ぎます。

チームメイトをシャットダウンする
チームメイトのセッションを適切に終了するには：
```
リサーチャーチームメイトにシャットダウンを依頼してください
```
リーダーはシャットダウンリクエストを送信します。チームメイトは承認して適切に終了するか、説明付きで拒否できます。

チームをクリーンアップする
完了したら、リーダーにクリーンアップを依頼します：
```
チームをクリーンアップしてください
```
これにより共有チームリソースが削除されます。リーダーがクリーンアップを実行すると、アクティブなチームメイトをチェックし、まだ実行中の場合は失敗するため、最初にシャットダウンしてください。
常にリーダーを使用してクリーンアップしてください。チームメイトはチームコンテキストが正しく解決されない可能性があるため、クリーンアップを実行すべきではありません。リソースが不整合な状態になる可能性があります。

フックで品質ゲートを強制する
フックを使用して、チームメイトが作業を完了したときやタスクが完了したときにルールを強制します：
- TeammateIdle：チームメイトがアイドル状態になろうとしているときに実行されます。コード2で終了してフィードバックを送信し、チームメイトに作業を続けさせます。
- TaskCompleted：タスクが完了としてマークされるときに実行されます。コード2で終了して完了を防ぎ、フィードバックを送信します。

エージェントチームの仕組み
このセクションでは、エージェントチームの背後にあるアーキテクチャとメカニズムについて説明します。使用を開始したい場合は、上記の「エージェントチームを制御する」を参照してください。

Claudeがエージェントチームを開始する方法
エージェントチームが開始される方法は2つあります：
- チームをリクエストする：並列作業の恩恵を受けるタスクをClaudeに与え、明示的にエージェントチームを依頼します。Claudeは指示に基づいてチームを作成します。
- Claudeがチームを提案する：Claudeがタスクが並列作業の恩恵を受けると判断した場合、チームの作成を提案する場合があります。続行する前に確認します。
どちらの場合も、あなたがコントロールを維持します。Claudeは承認なしでチームを作成しません。

アーキテクチャ
エージェントチームは以下で構成されます：

| コンポーネント | 役割 |
|---------------|------|
| チームリーダー | チームを作成し、チームメイトを生成し、作業を調整するメインClaude Codeセッション |
| チームメイト | 割り当てられたタスクをそれぞれ処理する別のClaude Codeインスタンス |
| タスクリスト | チームメイトが要求して完了する作業項目の共有リスト |
| メールボックス | エージェント間の通信のためのメッセージングシステム |

表示設定オプションについては「表示モードを選択する」を参照してください。チームメイトのメッセージはリーダーに自動的に届きます。
システムはタスクの依存関係を自動的に管理します。チームメイトが他のタスクが依存しているタスクを完了すると、ブロックされたタスクは手動の介入なしにブロック解除されます。
チームとタスクはローカルに保存されます：
- チーム設定：~/.claude/teams/{team-name}/config.json
- タスクリスト：~/.claude/tasks/{team-name}/
チーム設定には、各チームメイトの名前、エージェントID、エージェントタイプを含むメンバー配列が含まれています。チームメイトはこのファイルを読んで他のチームメイトを発見できます。

権限
チームメイトはリーダーの権限設定で開始されます。リーダーが--dangerously-skip-permissionsで実行されている場合、すべてのチームメイトも同様に実行されます。生成後、個別のチームメイトモードを変更できますが、生成時にチームメイトごとのモードを設定することはできません。

コンテキストと通信
各チームメイトは独自のコンテキストウィンドウを持ちます。生成されると、チームメイトは通常のセッションと同じプロジェクトコンテキスト（CLAUDE.md、MCPサーバー、スキル）を読み込みます。また、リーダーからの生成プロンプトも受け取ります。リーダーの会話履歴は引き継がれません。
チームメイトが情報を共有する方法：
- 自動メッセージ配信：チームメイトがメッセージを送信すると、受信者に自動的に配信されます。リーダーが更新をポーリングする必要はありません。
- アイドル通知：チームメイトが完了して停止すると、リーダーに自動的に通知されます。
- 共有タスクリスト：すべてのエージェントがタスクステータスを確認し、利用可能な作業を要求できます。
チームメイトのメッセージング：
- message：特定のチームメイトにメッセージを送信
- broadcast：すべてのチームメイトに同時に送信。コストはチームサイズにスケールするため、控えめに使用してください

トークン使用量
エージェントチームは単一セッションよりもはるかに多くのトークンを使用します。各チームメイトは独自のコンテキストウィンドウを持ち、トークン使用量はアクティブなチームメイトの数にスケールします。リサーチ、レビュー、新機能作業の場合、余分なトークンは通常 worth it です。ルーチンタスクの場合、単一セッションの方がコスト効果が高いです。使用ガイダンスについてはエージェントチームのトークンコストを参照してください。

ユースケースの例
これらの例は、並列探索が価値を生むタスクをエージェントチームがどのように処理するかを示しています。

並列コードレビューを実行する
単一のレビュアーは一度に1種類の問題に傾向があります。レビュー基準を独立したドメインに分割すると、セキュリティ、パフォーマンス、テストカバレッジがすべて同時に徹底的な注意を受けられます。プロンプトは各レビュアーに異なるレンズを割り当てるため、重複しません：
```
エージェントチームを作成してPR #142をレビューしてください。3人のレビュアーを生成してください：
- セキュリティへの影響に焦点を当てる1名
- パフォーマンスへの影響を確認する1名
- テストカバレッジを検証する1名
それぞれにレビューさせて発見を報告してください。
```
各レビュアーは同じPRから作業しますが、異なるフィルターを適用します。リーダーは完了後に3つすべての発見を統合します。

競合する仮説で調査する
根本原因が不明な場合、単一のエージェントは1つの妥当な説明を見つけて探査を停止する傾向があります。プロンプトはチームメイトを明示的に敵対的にすることでこれと戦います。各々の仕事は独自の理論を調査するだけでなく、他の理論に異議を唱えることでもあります。
```
ユーザーはアプリが1つのメッセージ後に終了し、接続されたままにならないと報告しています。
5人のエージェントチームメイトを生成して異なる仮説を調査させてください。
科学的議論のように互いの理論を反証しようとして話し合わせてください。
合計されたものが何であれ、調査結果ドキュメントを更新してください。
```
議論構造がここでの重要なメカニズムです。順次調査はアンカリングに悩まされます。1つの理論が探索されると、後続の調査はそれに偏向されます。
互いに反証しようと積極的に試みる複数の独立した調査者がいると、生き残った理論は実際の根本原因である可能性はるかに高くなります。

ベストプラクティス

チームメイトに十分なコンテキストを与える
チームメイトはプロジェクトコンテキスト（CLAUDE.md、MCPサーバー、スキル）を自動的に読み込みますが、リーダーの会話履歴は継承しません。詳細については「コンテキストと通信」を参照してください。生成プロンプトにタスク固有の詳細を含めてください：
```
セキュリティレビュアーチームメイトをプロンプトで生成してください：
「src/auth/の認証モジュールをセキュリティ脆弱性についてレビューしてください。
トークン処理、セッション管理、入力検証に焦点を当ててください。
アプリはhttpOnlyクッキーに保存されたJWTトークンを使用します。
重大度評価で問題を報告してください。」
```

タスクを適切にサイズ設定する
- 小さすぎる：調整のオーバーヘッドがメリットを上回ります
- 大きすぎる：チームメイトがチェックインなしに長時間作業し、無駄な努力のリスクが増えます
- ちょうど良い：明確な成果物（関数、テストファイル、レビューなど）を生成する自己完結型ユニット
リーダーは作業をタスクに分割し、自動的にチームメイトに割り当てます。十分なタスクを作成していない場合、作業をより小さなピースに分割するように依頼してください。チームメイトごとに5〜6個のタスクがあると、全員が生産的になり、誰かがスタックした場合にリーダーが作業を再割り当てできます。

チームメイトが完了するのを待つ
リーダーがチームメイトを待つ代わりにタスクの実装を開始することがあります。これに気づいた場合：
```
チームメイトがタスクを完了するのを待ってから続けてください
```

リサーチとレビューから始める
エージェントチームが初めての場合、明確な境界があり、コードを書く必要がないタスク（PRのレビュー、ライブラリのリサーチ、バグの調査）から始めてください。これらのタスクは、並列実装に伴う調整の課題なしに並列探索の価値を示します。

ファイルの競合を避ける
2人のチームメイトが同じファイルを編集すると上書きにつながります。各チームメイトが異なるファイルセットを所有するように作業を分割してください。

監視 and 誘導
チームメイトの進捗を確認し、機能しないアプローチを修正し、発見が入ってきたら統合してください。チームを長時間無人で実行しすぎると、無駄な努力のリスクが高まります。

トラブルシューティング

チームメイトが表示されない
Claudeにチームの作成を依頼した後にチームメイトが表示されない場合：
- インプロセスモードでは、チームメイトは既に実行されているが表示されない場合があります。Shift+Downを押してアクティブなチームメイトを循環してください。
- Claudeに与えたタスクがチームを正当化するのに十分複雑か確認してください。Claudeはタスクに基づいてチームメイトを生成するかどうかを決定します。
- 分割ペインを明示的にリクエストした場合、tmuxがインストールされ、PATHで利用可能か確認してください：
  ```
  which tmux
  ```
- iTerm2の場合、it2 CLIがインストールされ、Python APIがiTerm2設定で有効になっていることを確認してください。

権限プロンプトが多すぎる
チームメイトの権限リクエストはリーダーにバブルアップされ、摩擦を作成する可能性があります。チームメイトを生成する前に、権限設定で一般的な操作を事前に承認して中断を減らしてください。

チームメイトがエラーで停止する
チームメイトはエラーに遭遇した後に回復するのではなく停止することがあります。インプロセスモードでShift+Up/Downを使用するか、分割モードでペインをクリックして出力を確認し、次のいずれかを行います：
- 直接追加の指示を与える
- 作業を続行するために代替チームメイトを生成する

作業が完了する前にリーダーがシャットダウンする
リーダーはすべてのタスクが実際に完了する前にチームが完了したと判断する場合があります。これが発生した場合、続行するように伝えてください。リーダーが委任する代わりに作業を開始した場合は、続行する前にチームメイトが完了するのを待つように伝えることもできます。

孤立したtmuxセッション
チーム終了後にtmuxセッションが残存する場合、完全にクリーンアップされていない可能性があります。セッションを一覧表示し、チームによって作成されたセッションを強制終了します：
```
tmux ls
tmux kill-session -t <session-name>
```

制限事項
エージェントチームは実験的です。認識すべき現在の制限：
- インプロセスチームメイトでのセッション再開なし：/resumeと/rewindはインプロセスチームメイトを復元しません。セッションを再開した後、リーダーは存在しなくなったチームメイトにメッセージを送信しようとする場合があります。これが発生した場合、リーダーに新しいチームメイトを生成するように伝えてください。
- タスクステータスがラグする可能性があります：チームメイトはタスクを完了としてマークするのに失敗する場合があり、依存タスクがブロックされます。タスクがスタックしているように見える場合、作業が実際に完了しているか確認し、タスクステータスを手動で更新するか、リーダーにチームメイトを促すように伝えてください。
- シャットダウンが遅い場合があります：チームメイトはシャットダウンする前に現在のリクエストまたはツール呼び出しを完了し、これには時間がかかる場合があります。
- セッションあたり1つのチーム：リーダーは一度に1つのチームのみを管理できます。新しいチームを開始する前に現在のチームをクリーンアップしてください。
- ネストされたチームなし：チームメイトは独自のチームまたはチームメイトを生成できません。リーダーのみがチームを管理できます。
- リーダーは固定：チームを作成するセッションは生涯リーダーです。チームメイトをリーダーに昇格したり、リーダーシップを移転したりすることはできません。
- 生成時に権限を設定：すべてのチームメイトはリーダーの権限モードで開始されます。生成後に個別のチームメイトモードを変更できますが、生成時にチームメイトごとのモードを設定することはできません。
- 分割ペインにはtmuxまたはiTerm2が必要：デフォルトのインプロセスモードは任意のターミナルで機能します。分割ペインモードはVS Codeの統合ターミナル、Windows Terminal、Ghosttyではサポートされていません。
- CLAUDE.mdは正常に機能します：チームメイトは作業ディレクトリからCLAUDE.mdファイルを読み取ります。これを使用して、すべてのチームメイトにプロジェクト固有のガイダンスを提供します。

次のステップ
並列作業と委任のための関連アプローチを探索してください：
- 軽量な委任：サブエージェントはセッション内でリサーチまたは検証のためのヘルパーエージェントを生成し、エージェント間の調整を必要としないタスクに適しています
- 手動の並列セッション：Git worktreesを使用して、自動化されたチーム調整なしで独自に複数のClaude Codeセッションを実行できます
- アプローチの比較：並列比較についてはサブエージェントとエージェントチームの比較を参照してください
